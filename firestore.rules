rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ===================================
    // Helper Functions
    // ===================================
    function isAdmin() {
      return request.auth.token.email == 'jwag.lang@gmail.com';
    }

    function isAuthenticated() {
      return request.auth != null;
    }

    function isTeacher() {
      return isAuthenticated() && exists(/databases/$(database)/documents/teacherProfiles/$(request.auth.uid));
    }

    function isOwner(uid) {
      return isAuthenticated() && request.auth.uid == uid;
    }

    function isAssociatedStudent(studentId) {
      return isAuthenticated() &&
             exists(/databases/$(database)/documents/students/$(studentId)) &&
             get(/databases/$(database)/documents/students/$(studentId)).data.email == request.auth.token.email;
    }

    // Returns teacher UID assigned to a given studentId (or null if missing)
    function assignedTeacherUid(studentId) {
      return get(/databases/$(database)/documents/students/$(studentId)).data.assignedTeacherId;
    }

    // Checks whether a uid belongs to a teacher profile
    function isTeacherUid(uid) {
      return exists(/databases/$(database)/documents/teacherProfiles/$(uid));
    }

    // Checks whether a uid belongs to a student document id (studentId)
    function isStudentUid(uid) {
      return exists(/databases/$(database)/documents/students/$(uid));
    }

    // For an existing message doc: allow participant-based reads for students
    // Our participant key convention is: ["teacherUid:studentId"]
    function isParticipantForDoc() {
      // Only applies if participants exists and is a list
      return (resource.data.participants is list) &&
        (
          // If the authed user is the student (associated to studentId), allow if participants contains (assignedTeacherUid:studentId)
          (isAssociatedStudent(resource.data.to) &&
            resource.data.participants.hasAny([assignedTeacherUid(resource.data.to) + ":" + resource.data.to])) ||

          (isAssociatedStudent(resource.data.from) &&
            resource.data.participants.hasAny([assignedTeacherUid(resource.data.from) + ":" + resource.data.from]))
        );
    }

    // For creates: validate participants matches the student<->teacher relationship
    function isParticipantForCreate() {
      return (request.resource.data.participants is list) &&
        request.resource.data.participants.size() == 1 &&
        request.resource.data.participants[0] == (request.resource.data.to + ":" + request.resource.data.from);
    }

    // ===================================
    // Collection Rules
    // ===================================

    match /students/{studentId} {
      allow read, list: if isAuthenticated();
      allow create: if isAuthenticated() && request.resource.data.email == request.auth.token.email;
      allow update, delete: if isAdmin() || isTeacher();
    }

    match /lessons/{lessonId} {
      allow read, list: if isAuthenticated();
      allow write: if isAdmin() || isTeacher();
    }

    match /availability/{availId} {
      allow read, list: if true;
      allow write: if isAdmin() || isTeacher();
    }

    match /courseTemplates/{courseId} {
      allow read, list: if true;
      allow write: if isAdmin() || isTeacher();
    }

    match /courses/{courseId} {
      allow read, list: if true;
      allow write: if isAdmin() || isTeacher();
    }

    match /teacherProfiles/{teacherId} {
      allow read, list: if isAuthenticated();
      allow write: if isOwner(teacherId) || isAdmin();
    }

    match /reviews/{reviewId} {
      allow read, list: if isAuthenticated();
      allow create: if isAuthenticated();
      allow update, delete: if isAdmin() || isTeacher();
    }

    match /approvalRequests/{reqId} {
      allow create: if isAuthenticated();
      allow read, list: if isAuthenticated();
      allow update, delete: if isAdmin() || isTeacher();
    }

    match /userSettings/{settingId} {
      allow read, write: if isAuthenticated();
    }

    match /studentPackages/{pkgId} {
      allow read, list: if isAuthenticated();
      allow write: if isAdmin() || isTeacher();
    }

    match /units/{unitId} {
      allow read, list: if isAuthenticated();
      allow write: if isAdmin() || isTeacher();
    }

    match /levels/{levelId} {
      allow read, list: if isAuthenticated();
      allow write: if isAdmin() || isTeacher();
    }

    match /sessions/{sessionId} {
      allow read, list: if isAuthenticated();
      allow write: if isAdmin() || isTeacher();
    }

    match /homeworks/{homeworkId} {
      allow read, list: if isAuthenticated();
      allow write: if isAdmin() || isTeacher();
    }

    match /projects/{projectId} {
      allow read, list: if isAuthenticated();
      allow write: if isAdmin() || isTeacher();
    }

    match /homeworkSubmissions/{submissionId} {
      allow read, list: if isAuthenticated();
      allow create: if isAuthenticated();
      allow update: if isAuthenticated();
      allow delete: if isAdmin() || isTeacher();
    }

    match /studentProgress/{progressId} {
      allow read, list: if isAuthenticated();
      allow write: if isAdmin() || isTeacher();
    }

    match /studentRewards/{rewardId} {
      allow read, list: if isAuthenticated();
      allow write: if isAdmin() || isTeacher();
    }

    match /assessmentReports/{reportId} {
      allow read, list: if isAuthenticated();
      allow write: if isAdmin() || isTeacher();
    }

    match /studentCredit/{creditId} {
      allow read, list: if isAuthenticated();
      allow write: if isAdmin() || isTeacher();
    }

    // ===================================
    // MESSAGES (Chat + Notifications)
    // ===================================
    match /messages/{messageId} {

      // Teachers/Admins have full access
      allow read, write: if isTeacher() || isAdmin();

      // Students can read messages they sent or received (legacy) OR via participants key (new)
      allow read: if
        isAssociatedStudent(resource.data.from) ||
        isAssociatedStudent(resource.data.to) ||
        isParticipantForDoc();

      // Students can create messages originating from themselves,
      // only to their assigned teacher, and with valid participants key.
      allow create: if
        isAuthenticated() &&
        // from must be a studentId associated to this authed user
        isAssociatedStudent(request.resource.data.from) &&
        request.resource.data.fromType == 'student' &&
        // to must be the assigned teacher uid for that student
        (request.resource.data.to == assignedTeacherUid(request.resource.data.from)) &&
        request.resource.data.toType == 'teacher' &&
        // type must be one of the two supported values
        (request.resource.data.type == 'communications' || request.resource.data.type == 'notification') &&
        // participants must be ["teacherUid:studentId"]
        isParticipantForCreate();

      // Students may only mark a message as read if they are the recipient and only toggling read false->true.
      allow update: if
        isAuthenticated() &&
        isAssociatedStudent(resource.data.to) &&
        resource.data.read == false &&
        request.resource.data.read == true &&
        // prevent changing anything else
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['read']);
    }
  }
}
